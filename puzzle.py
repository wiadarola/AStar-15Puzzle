#!/usr/bin/python3

"""
CS 4613
William Iadarola
Project 1: 15 Puzzle with A* Search
4/11/2021
"""

import argparse
from queue import PriorityQueue
from copy import deepcopy


class Node:
    def __init__(self):
        self.state = [None] * 16
        self.blank = 0
        self.cost = 0
        self.depth = 0
        self.path = ([], [])  # actions, f(n) values

    def __lt__(self, rhs):
        if self.cost < rhs.cost:
            return True
        else:
            return False
    
    def getActions(self):
        """
        Returns tuple of virtually defined moves based on the position of the blank tile.
        """
        actions = {
            0: (5,6,7),
            1: (1,5,6,7,8),
            2: (1,5,6,7,8),
            3: (1,7,8),
            4: (3,4,5,6,7),
            8: (3,4,5,6,7),
            5: (1,2,3,4,5,6,7,8),
            6: (1,2,3,4,5,6,7,8),
            9: (1,2,3,4,5,6,7,8),
            10: (1,2,3,4,5,6,7,8),
            7: (1,2,3,7,8),
            11: (1,2,3,7,8),
            12: (3,4,5),
            13: (1,2,3,4,5),
            14: (1,2,3,4,5),
            15: (1,2,3)
        }
        return actions.get(self.blank) 

    def execute(self, action):
        """
        Appends the current action to list of actions in path.
        Swaps blank tile and tile specified by action parameter.
        """
        self.path[0].append(str(action))
        if action == 1:
            self.state[self.blank], self.state[self.blank-1] = self.state[self.blank-1], self.state[self.blank]
            self.blank = self.blank - 1
        elif action == 2:
            self.state[self.blank], self.state[self.blank-5] = self.state[self.blank-5], self.state[self.blank]
            self.blank = self.blank - 5
        elif action == 3:
            self.state[self.blank], self.state[self.blank-4] = self.state[self.blank-4], self.state[self.blank]
            self.blank = self.blank - 4
        elif action == 4:
            self.state[self.blank], self.state[self.blank-3] = self.state[self.blank-3], self.state[self.blank]
            self.blank = self.blank - 3
        elif action == 5:
            self.state[self.blank], self.state[self.blank+1] = self.state[self.blank+1], self.state[self.blank]
            self.blank = self.blank + 1
        elif action == 6:
            self.state[self.blank], self.state[self.blank+5] = self.state[self.blank+5], self.state[self.blank]
            self.blank = self.blank + 5
        elif action == 7:
            self.state[self.blank], self.state[self.blank+4] = self.state[self.blank+4], self.state[self.blank]
            self.blank = self.blank + 4
        else:
            self.state[self.blank], self.state[self.blank+3] = self.state[self.blank+3], self.state[self.blank]
            self.blank = self.blank + 3


def search(initial, goal):
    """
    A* search: Uses a priority queue to expand nodes in increasing f(n) values.
    f(n) is calculated for new nodes by calling update_cost().
    Places new children in queue if lookup() returns True.
        Return:
        Tuple(Node, int)
            Node = if success: goal state node; else: initial node
            int = if success: total nodes generated; else: -1
    """
    total = 1  # initial one node
    frontier = PriorityQueue()
    frontier.put((initial.cost, initial))  # tuple of f(n), node for queue
    reached = [initial]  # look-up table to disallow repeats of increasing cost
    while not frontier.empty():
        node = frontier.get()[1]  # retrieve min f(n) node
        if node.state == goal.state:  # if node is goal
            return (node, total)  # return node and num of nodes generated (endif)
        for child in expand(node):  # expand current node
            update_cost(child, goal)  # generate new cost for child node
            if lookup(child, reached):  # if child should be expanded
                frontier.put((child.cost, child))  # place child in queue, else child is garbage
                total += 1  # increase nodes generated (endif)
    return (initial, -1)  # nodes generated -1 to indicate failure to find solution path


def expand(node):
    """
    Generates child nodes by performing swaps generated by getActions() on param Node
    and executed by execute(). Children are initially deep copies of parents
    with increased depth.
    """
    for action in node.getActions():
        child = deepcopy(node)
        child.execute(action)
        child.depth += 1
        yield child


def update_cost(node, goal):
    """
    Updates cost of passed Node based on sum of chessboard distances 
    of numbered tiles to their positions in the passed goal node.
    Math based on 2D game board implemented in a 1D array.
    """
    for i in range(1, 16):
        vdist = abs(goal.state.index(i)%4 - node.state.index(i)%4)
        hdist = abs(goal.state.index(i)//4 - node.state.index(i)//4)
        node.cost += max(vdist, hdist)  # cost += max of horizontal and vertical distances
    node.path[1].append(str(node.cost))  # append new cost to f(n) vals in node's path


def lookup(node, table):
    """
    Searches passed look-up table for passed Node.
    Replaces Node in table if passed Node is cheaper.
    Appends node to table if not found.
        Return:
        Bool = True if Node should be placed in frontier, False otherwise
    """
    for i in range(len(table)):
        if node.state == table[i].state and node < table[i]:  # passed node is cheaper
            table[i] = node
            return True
        elif node.state == table[i].state:  # passed Node is costlier
            return False
    table.append(node)  # passed node not found in table
    return True


def get_file():
    """
    Retrieves file from command line.
    """
    parser = argparse.ArgumentParser(description='Solver 15 Puzzle with A* Search')
    parser.add_argument('filename', help='The file containing initial and goal states, typically with .txt suffix')
    return parser.parse_args()


def fill_state(lines, output, start):
    """
    Creates state for new Node based on passed lines. 
    Writes initial and goal states to output file.
    Sets Node.blank when a 0 is added to the Node's state.
        Parameters:
        lines = list of lines extracted from input file
        output = output file
        start = index of starting line for state fill

        Return:
        Node = generated node obj with filled state
    """
    node = Node()
    ind = 0
    for i in range(4):
        output.write(lines[start + i])
        for val in lines[start + i].split():
            node.state[ind] = int(val)
            if val == '0':  # sets blank location
                node.blank = ind
            ind += 1
    output.write('\n')
    return node


def write_data(output, result):
    """
    Writes to output file (output.txt) based on passed result tuple
    generated by search().
    """
    if result[1] != -1:  # If solution path found
        output.write(str(result[0].depth) + '\n')  # depth of solution
        output.write(str(result[1]) + '\n')  # total nodes generated 
        actions = ' '.join(result[0].path[0]) + '\n'  # actions in path
        output.write(actions)
        costs = ' '.join(result[0].path[1])  # f(n) values in path
        output.write(costs)
    else:  # solution path was not found (-1 nodes generated)
        output.write("Failure: Could not find a solution.")


def main():
    cmdline = get_file()
    with open(cmdline.filename) as inp:
        lines = inp.readlines()
    with open('output.txt', 'w') as output:
        initial = fill_state(lines, output, 0)  # create initial node
        goal = fill_state(lines, output, 5)  # create goal node
        update_cost(initial, goal)  # set cost of inital node
        result = search(initial, goal)  # search for solution
        write_data(output, result)  # write to output based on result


if __name__ == "__main__":
    main()
